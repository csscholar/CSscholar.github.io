class Filter{constructor(e,t,r="year",s="venue_acronym_acronym"){this.years_=e,this.venues_=t,this.yearColumn_=r,this.venueColumn_=s}isValid(e){return this.years_.includes(e[this.yearColumn_])&&this.venues_.includes(e[this.venueColumn_])}}class Dataset{constructor(e){this.data_=e}getUnique(t,e=!0){var r=new Set(this.data_.map(e=>e[t]));return e&&r.delete(""),Array.from(r)}getFilteredData(t){return t?this.data_.filter(e=>t.isValid(e)):this.data_}groupBy(e,t=null){var r,s={};for(r of this.getFilteredData(t)){var n=r[e];n in s||(s[n]=[]),s[n].push(r)}return s}getColumnsByAuthor(e,t=null){var r,s,n=this.groupBy("authors_name",t);for([r,s]of Object.entries(n)){for(var a of s)0!=+a.referenceCount?a.selfCitationPercent=a.authors_selfCitations/+a.referenceCount*100:a.selfCitationPercent=0;n[r]=convertArrayToObjectOfLists(s),getColumnSubset(n[r],e)}return n}}function getColumnSubset(e,t){for(var r of Object.keys(e))t.includes(r)||delete e[r]}function convertArrayToObjectOfLists(e){const r={};return e.forEach(t=>{Object.keys(t).forEach(e=>{void 0===r[e]?r[e]=[t[e]]:r[e].push(t[e])})}),r}export{Dataset,Filter};